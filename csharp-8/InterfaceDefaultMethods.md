# Lo nuevo en C# 8.0 - Default Interface Methods

Con la llegada de `C# 8.0` nuestras inferfaces permiten incluir implementaciones genÃ©ricas para los mÃ©todos que declaran y poder ser compartidos entre las diferentes clases de implementaciÃ³n de la interfaz tal como se puede realizar con las clases abstractas.

Esta posibilidad nos brinda posibilidades totalmente nuevas como la de pensar en utilizar `Mixins`; pero tambiÃ©n dudas sobre cuando utilizarlo y algÃºn que otro dolor de cabeza al permitir una pseudo-multiherencia y apareciendo el `problema del diamante`.

> **Info:** No es algo novedozo, Java ya lo acepta desde la version 8 [link](https://www.geeksforgeeks.org/default-methods-java/)

## ImplementaciÃ³n

### 1. ImplementaciÃ³n bÃ¡sica

```csharp
public interface IMyClassA
{
    public void Works() => Console.WriteLine("Hello from InterfaceA");
}

public class MyClassA : IMyClassA {}

IMyClassA myClass = new MyClassA();
myClass.Works();
// -- output: Hello from InterfaceA
```

Notese que debemos tipificar el tipo de `myClass` a la interface porque si utilizamos `var` o `MyClassA` el compilador va a generar un error indicando que no encuentra `works()` en la clase.

![Error message](./assets/error_1.png)

Realmente no hay mucha diferencia con respecto a lo que podemos hacer con una clase abstracta hasta este momento no? ðŸ™„

### 2. Extendiendo la interfaz y sobre-escribiendo el Default Method

Â¿Podemos extender la interfaz si sobre escribir el metodo default que creamos en `IMyClassA`? Totalmente SI! ðŸ™Œ

```csharp
public interface IMyClassAOverride : IMyClassA
{
    public new void Works() => Console.WriteLine("Hello from IMyClassAOverride");
}
public class MyClassAOverride : IMyClassAOverride {}

IMyClassAOverride myClassAOverride = new MyClassAOverride();
myClassAOverride.Works();
// -- output: "Hello from IMyClassAOverride"
```

Pueden ver que al realizar el `override` del metodo `Works()` se esta utilizando el modificar `new` el cual hace que se oculte la implementaciÃ³n de base del metodo al que modifica ([documentaciÃ³n](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/new-modifier)).

TambiÃ©n podemos sobre-escribirlo de la siguiente manera

```csharp
public interface IMyClassEOverride : IMyClassE
{
    void IMyClassE.Works()
    {
        Console.WriteLine("Hello from IMyClassEOverride");
    }
}
```

### 3. Implementando una interfaz con Default Methods y otra sin Default Methods

Puede pasar que tengamos una clase que implemente 2 interfaces que definen el mismo metodo `Works()` pero que una la implemente con Default Methods y la otra no... Â¿QuÃ© pasa en estos casos? Â¿Reconoce que el mÃ©todo ya esta implementado o no?

```csharp
public interface IMyClassC
{
    void Works();
}

public class MyClassWithMutiInterfacesWithNoDefaults : IMyClassA, IMyClassC
{
    public void Works() => Console.WriteLine("Hello from MyClassWithMutiInterfacesWithNoDefaults");
}

// probemos tipificando con las diferentes posibilidades
MyClassWithMutiInterfacesWithNoDefaults myClassWithMutiInterfacesWithNoDefaults = new MyClassWithMutiInterfacesWithNoDefaults();
myClassWithMutiInterfacesWithNoDefaults.Works();
// -- output: Hello from MyClassWithMutiInterfacesWithNoDefaults

IMyClassA myClassWithMutiInterfacesWithNoDefaultA = new MyClassWithMutiInterfacesWithNoDefaults();
myClassWithMutiInterfacesWithNoDefaultA.Works();
// -- output: Hello from MyClassWithMutiInterfacesWithNoDefaults

IMyClassC myClassWithMutiInterfacesWithNoDefaultC = new MyClassWithMutiInterfacesWithNoDefaults();
myClassWithMutiInterfacesWithNoDefaultC.Works();
// -- output: Hello from MyClassWithMutiInterfacesWithNoDefaults
```

Pues no... nos solicita que implementemos el mÃ©todo y ademÃ¡s, sea como sea que lo utilicemos, siempre ejecuta la versiÃ³n del mÃ©todo sobreescrito.

### 4. Â¿Que podemos hacer con propiedades?

Lamentablemente no mucho. No esta permitido tener un "estado" en la interfaz por lo que solo permite definir un valor por default al `getter/setter` y luego tocarÃ¡ sobre-escribirlo

```csharp
public interface IMyClassD
{
    public string Name {
        get {
            return "Andres";
        }
        private set { }
    }
}
```

En el ejemplo el `set` lo hice privado, pero unicamente para seÃ±alar que de esta forma se puede crear un valor constante o un valor default para todas las implementaciones

Referencias

* [Excelente y completÃ­sima explicaciÃ³n](https://www.infoq.com/articles/default-interface-methods-cs8/)
* [Microsoft C# 8 news](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-8#default-interface-methods)
* [Microsoft C# 8 proposal](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods)
* [Microsof Update to Interface Methods](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/default-interface-methods-versions)


## Problema del Diamante

Como deciamos en un principio. el advenimiento de esta nueva funcionalidad en C# 8.0 trae la posibilidad de caer en el Problema del diamante tan temido cuando un lenguaje permite Multi-Herencia.

El problema del diamante plantea la exitencia de 2 o mÃ¡s clases (clase `A` y clase `B`) que implementan un mismo mÃ©todo, por ejemplo `Run()`, y otra clase `C` que extiende de ellas (es lo que permite la herencia mÃºltiple), entonces, Â¿cuÃ¡l versiÃ³n de `Run()` debe ser utilizada?

Hay varias estrategias para resolver este problem, como por ejemplo tomar la primer implementaciÃ³n que encuentra y descartar el resto.

GrÃ¡ficamente se ilustra de la siguiente forma ([imagen obtenida de aquÃ­](https://es.stackoverflow.com/questions/104165/por-qu%C3%A9-la-herencia-m%C3%BAltiple-no-se-admite-en-java)):
![Problema del diamante](./assets/diamante.png)

C# 8.0 y su Inteface Default Implementation aborda el problema desde el punto de las interfaces, o sea una clase va a presentar este problema si dos o mas de las interfaces que implementa tienen implementado el mismo mÃ©todo (ya vimos anteriormente que pasa si una de ellas lo declara y no lo implementa).

```csharp
public interface IMyClassA
{
    public void Works() => Console.WriteLine("Hello from InterfaceA");
}

public interface IMyClassB
{
    void Works() => Console.WriteLine("Hello from InterfaceB");
}

public class MyClassWithMultiInterfaces: IMyClassA, IMyClassB { }

IMyClassB myClassWithMultiInterfacesB = new MyClassWithMultiInterfaces(); // gets the more implicit Interface in multi-hieritance
myClassWithMultiInterfacesB.Works();
// -- output: Hello from InterfaceB

IMyClassA myClassWithMultiInterfacesA = new MyClassWithMultiInterfaces(); // gets the more implicit Interface in multi-hieritance
myClassWithMultiInterfacesA.Works();
// -- output: Hello from InterfaceA

MyClassWithMultiInterfaces myClassWithMultiInterfaces = new MyClassWithMultiInterfaces();
// myClassWithMultiInterfaces.Works(); <-- compilation error, pasa esto porque no sobreescribimos el mÃ©todo en la clase
```

Como podemos ver, C# 8.0 no toma mucha desiciÃ³n y deja al programador decidir. En este caso debemos tipificar la variable para que el compilador sepa cual implementaciÃ³n utilizar.

Realmente, en este momento, no se me ocurre algun caso real que pase esto... aunque aÃºn es muy nuevo y ya llegarÃ¡n los dolores de cabeza ðŸ˜ˆðŸ˜…

Referencias a herencia mÃºltiple:

* [Wikipedia](https://es.wikipedia.org/wiki/Herencia_m%C3%BAltiple)
* [Pdf](https://ingenieria.udistrital.edu.co/pluginfile.php/39191/mod_resource/content/1/Herencia%20m%C3%BAtiple.pdf)
* [StackOverflow](https://es.stackoverflow.com/questions/104165/por-qu%C3%A9-la-herencia-m%C3%BAltiple-no-se-admite-en-java)

## Mixins

Un Mixin es una clase generada a partir de la uniÃ³n de otras clases, o sea, la clase `A` define el mÃ©todo `Save()` y la clase `B` define el mÃ©todo `SaveAsync()`, por lo tanto la clase `C` que extiende a ambas es el resultado de la concatenaciÃ³n de todos los miembros de las clases que implementa. La clase resultante es el Mixin (tambiÃ©n se les dice Mixin a las clases parciales base).

En el mundo de C# los Mixin no son tan conocidos, es mÃ¡s, si alguien nunca saliÃ³ del mundo Microsoft talvez es la primera vez que escuche nombrar el concepto de Mixin, pero no es para nada nuevo. Es algo archi/hiper conocido en front end y mas precisamente en pre-procesador como Sass. Otros lenguajes como Python lo permiten de forma mativa o como Java que tambiÃ©n lo permite con librerÃ­as de terceros o bien nativamente con Interface Default Methods como en C#.

Una de las bondades ques se dice sobre los Mixin es que permite extender la funcionalidad de muchas clases con un solo codigo (cÃ³digo escrito en un Ãºnico lado) con solo hacer referencia que la clase depende de Ã©sta.

Alguno podrÃ¡ decir que es algo similar a las class extentions.... pues sÃ­, en parte sÃ­. Una de las diferencias que veo es que en este caso los mixin se verifican en tiempo de compilaciÃ³n y las class extentions pueden llegar a ser dinÃ¡micas si llegamos a cargar .dll de forma dinÃ¡mica. Diferencia que en parte desaparece si usamos Proxies generados dinÃ¡micamente (las librerÃ­as de Mixin hace eso), pero el objeto que tendriamos serÃ­a un Proxy (como cuando utilizamos Moq en los test) y no el objeto real, aunque esta generaciÃ³n dinÃ¡mica tiene su costo en los recursos en tiempo de ejecuciÃ³n cosa que los Default Methods no.

Veamos un ejemplo de una lamparita

Primero creamos la interfaz base y una clase base

```csharp
interface ILight
{
    protected enum STATUS
    {
        ON,
        OFF
    }

    protected STATUS Status { get; set; }

    public bool IsOn() => Status == STATUS.ON;

    public bool isOff() => Status == STATUS.OFF;

    public void SwitchOff() => Status = STATUS.OFF;

    public void SwitchOn() => Status = STATUS.ON;
}

public class BaseLight : ILight
{
    STATUS ILight.Status { get; set; } = STATUS.OFF;
}
```

Ahora creamos otras interfaces que extienden de `ILight` las cuales agregan funcionalidad nueva, una que permita tener un delay en el encendido/apagado y otra que permita tener lamparitas de colores

```csharp
interface ITimerLight : ILight
{
    public async void DelaySwithOff(int duration)
    {
        await Task.Delay(duration);
        SwitchOff();
    }

    public async void DelaySwithOn(int duration)
    {
        await Task.Delay(duration);
        SwitchOn();
    }
}

public interface IColoredLight : ILight
{
    public enum COLOR
    {
        RED,
        YELLOW,
        WHITE,
        BLUE
    }

    protected COLOR SelectedColor { get; set; }

    public void SetColor(COLOR value) => SelectedColor = value;
}
```

Ahora podemos crear cualquier cantidad de objetos unicamente ensamblando los diferentes componentes

```csharp
// Lamparita bÃ¡sica
public class SimpleLight : BaseLight { }

// Lamparita con delay
public class TimerLight : BaseLight, ITimerLight { }

// Lamparita con varias funcionalidades
public class CrazyLight : BaseLight, ITimerLight, IColoredLight
{
    COLOR IColoredLight.SelectedColor { get; set; } = COLOR.WHITE;
}
```

Finalmente las utilizamos de la siguiente manera

```csharp
ILight light = new SimpleLight();
light.SwitchOn();
light.SwitchOff();

ITimerLight timerLight = new TimerLight();
timerLight.DelaySwithOn(1);
timerLight.DelaySwithOff(2);

CrazyLight crazyLight = new CrazyLight();
((IColoredLight)crazyLight).SetColor(COLOR.RED);
((ITimerLight)crazyLight).DelaySwithOn(1);
```

Por lo que veo, la posibilidad del Mixin estÃ¡ pero creo que entro como de costado... como consecuencia de las Default Methods y el equipo que se encarga del update del lenguaje creo que tiene muchas posibilidades para desarrollar Mixins de una manera mucho mas amigable hacia el programador como por ejemplo que no se tenga que castear a cada interfaz para utilziar cada mÃ©todo.

Referencias

* [Wikipedia](https://es.wikipedia.org/wiki/Mixin)
* [Microsoft](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/mixins-with-default-interface-methods)
* [Ejmplo Python - recomendado](https://pythonista.io/cursos/py111/mixins)
* [Ejemplo Java](https://www.arquitecturajava.com/java-mixins-un-ejemplo-sencillo/)
* [CSS SASS](https://css-tricks.com/custom-user-mixins/)

## ConcluciÃ³n

Creo que es una nueva funcionalidad que abre la puerta a nuevas formas de diseÃ±ar y pensar una aplicaciÃ³n desde el diseÃ±o bÃ¡sico, buscando nuevos patrones de reutilizaciÃ³n de lÃ³gica de negocio y cÃ³digo; abriendo la posibilidad a herencia mÃºltiple y uso de Mixins pero no lo veo 100% como algo cerrado.

La imposibilidad de utiliar `var` o la clase al declarar la variable y utilizar los mÃ©todos definidos en la intefaz hace que sea engorroso tener que castearlo cada vez, mÃ¡s allÃ¡ que lleva a un overhead de tener que conocer mucho mÃ¡s en profundidad todas las clases ya que no el IDE no te auto-completa con esos mÃ©todos si no casteas a la interfaz correcta (ni hablar si tenes mas de una interfaz).

Por lo pronto, creo que no es una funcionalidad que la utilice mucho en un proyecto de producciÃ³n. Â¿QuÃ© piensan ustedes?
